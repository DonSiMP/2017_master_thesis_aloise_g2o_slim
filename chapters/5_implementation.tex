\chapter{Software Implementation of the Optimizer}\label{ch:implementation}
This Chapter will better analyze the actual implementation of a 3D Optimizer. In particular, it has been developed a self-consistent C++ library that provides all the tools needed to create and optimize 3D graphs that contain \textit{pose} or \textit{point} objects. The main components of the system are basically two:

\begin{enumerate}
    \item The \texttt{Optimizer} itself that runs the Gauss-Newton algorithm to retrieve the best state configuration given the constraints.
    \item The \texttt{Graph}, that contains the actual nodes and edges generated by a suitable front-end or read from file.
\end{enumerate}

While the \texttt{Graph} is just a \textit{container} for nodes and edges, the optimizer has to perform several computations in order to retrieve the linear system $\hessian \dx = -\bvec$ and then solve it. Therefore, underlying the optimizer a linear solver is required to efficiently solve the aforementioned system. 

It is good to notice that our system is almost completely self-contained: the only external libraries employed are \textit{Eigen} - \hyperref{http://eigen.tuxfamily.org}{}{}{site} -  to efficiently manage small matrices  and \textit{SuiteSparse}  - \hyperref{http://faculty.cse.tamu.edu/davis/suitesparse.html}{}{}{site} - only to compute the right permutation of the Hessian. Therefore, in the next Sections is proposed an insight of the main components of the \texttt{Optimizer}.

\section{Graph}\label{sec:graph_implementation}
The \texttt{Graph} is basically constituted by a collection of edges and nodes. The nodes can be either of type \textit{pose} or \textit{point} - represented respectively by the objects \texttt{VertexSE3} and \texttt{VertexR3}. Each vertex is represented by

\begin{itemize}
    \item Its \textbf{estimate}, which can be a 3D isometry or a 3D position - namely a \texttt{Pose3D} or a \texttt{Point3D}
    \item A unique \textbf{index} that is used to recognize the vertex
\end{itemize}

Analogously, the edge are of type \textit{pose-pose} or \textit{pose-point} - represented respectively by the objects \texttt{EdgeSE3} and \texttt{EdgeSE3\_R3}. The edge have several fields, namely:

\begin{itemize}
    \item The actual \textbf{measurement} that can be either a \texttt{Pose3D} or a \texttt{Point3D}
    \item The \textbf{data association} that consists in a pair of \texttt{Vertex} which represents the nodes involved in the edge
    \item The \textbf{information matrix} related to the measurement - namely a \texttt{Matrix6} or a \texttt{Matrix3}.
\end{itemize}

Once that the front-end populates the graph, it is fed into the \texttt{Optimizer} to perform MAP estimation of the best state configuration given the constraints.
\section{The Optimizer}\label{sec:optimizer}
The \texttt{Optimizer} represents systems' heart: it takes as input the graph, retrieves the linear system $\hessian \dx = -\bvec$, solves for $\dx$ and finally updates the graph. In the following Sub-sections the core elements of the \texttt{Optimizer} will be better investigated.

\subsection{Linearization and Hessian Composition}\label{subsec:linearize}
The main task of the \texttt{Optimizer} is to compute the contribution that each edge brings to both the Hessian matrix $\hessian$ and the right-hand-side vector $\bvec$. Those contribution are retrieved during the \textit{linearization} of the graph. 

Each edge of the graph is analyzed, whether it is a \texttt{EdgeSE3} or a  \texttt{EdgeSE3\_R3}. For each measurement the block matrices $\hessian_{ii}$, $\hessian_{ij}$, $\hessian_{ji}$ and $\hessian_{jj}$ are computed as
\begin{empheq}[box={\mybluebox[3pt]}]{equation}
    \label{eq:j_omega_j}
    \begin{matrix}
        \hessian_{ii} = \jacob_i^T \Omega_k \jacob_i & \hessian_{jj} = \jacob_j^T \Omega_k \jacob_j \\
        \hessian_{ij} = \jacob_i^T \Omega_k \jacob_j & \hessian_{ji} = \jacob_j^T \Omega_k \jacob_i
    \end{matrix}
\end{empheq}
\noindent while the right-hand-side contributions are computed as 

\begin{empheq}[box={\mybluebox[3pt]}]{equation}
    \label{eq:j_omega_e}
    \bvec_i = \jacob_i^T \Omega_k \error_k \qquad \bvec_j = \jacob_j^T \Omega_k \error_k
\end{empheq}

The subscript indexes $\langle i, j \rangle$ are the node unique indexes in the current edge's data-association. The tuple $\langle i, j \rangle$ indicates the position of each block in the full Hessian $\hessian$ (and in the full right-hand-side vector $\bvec$).

The Jacobians $\jacob_i$ and $\jacob_j$ are using Equations \ref{eq:jac_i_se3} and \ref{eq:jac_j_se3} for pose constraints, while for point ones Equations \ref{eq:jac_r_se3r3} and \ref{eq:jac_l_se3r3}. Clearly, as reported in Section \ref{sec:se3_objects}, the information matrix of each \texttt{EdgeSE3} is adapted through the Unscented Transform before starting the optimization process - and \textit{not} at each iteration.

\subsection{Sparse Linear Solver}\label{subsec:sparse_linear_solver}
